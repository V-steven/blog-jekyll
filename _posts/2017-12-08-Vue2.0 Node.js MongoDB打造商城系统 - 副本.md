---
layout: post
title: Vue2.0 Node.js MongoDB打造商城系统
tags: [前端后台]
---

Get全栈技能点 Vue2.0/Node.js/MongoDB 打造商城系统，一段时间的学习，记下此笔记，嘿嘿~~~~

---

# 1. 内容目录
- [1. 内容目录](#1-内容目录)
- [2. 前言介绍和环境搭建](#2-前言介绍和环境搭建)
    - [1. vue和react对比](#1-vue和react对比)
    - [2. 工程环境配置](#2-工程环境配置)
- [3. 路由基础和路由种类](#3-路由基础和路由种类)
    - [1. 安装路由依赖](#1-安装路由依赖)
    - [2. vue-router代码解析](#2-vue-router代码解析)
- [4. Vue-resource/Axios](#4-Vue-resource/Axios)
    - [1. 插件安装](#1-插件安装)
    - [2. Vue-resource插件介绍](#2-Vue-resource插件介绍)
    - [3. Axios插件介绍](#3-Axios插件介绍)
- [5. ES6基础和Promise讲解](#5-ES6基础和Promise讲解)
    - [1. ES6的基础知识变量作用域](#1-ES6的基础知识变量作用域)
    - [2. ES6参数、函数、数组](#2-ES6参数、函数、数组)
    - [3. Promise的使用方法](#3-Promise的使用方法)
- [6. 模块组件化和数据加载](#6-模块组件化和数据加载)
    - [1. 模块组件化](#1-模块组件化)
    - [2. 数据渲染加载](#2-数据渲染加载)
    - [3. 实现图片懒加载](#2-实现图片懒加载)
- [7. NODE相关知识点](#7-NODE相关知识点)
    - [1. NODE安装配置](#1-NODE安装配置)
    - [2. NODE基础编程-http](#2-NODE基础编程-http)
    - [3. NODE搭建服务器加载静态页面](#3-NODE搭建服务器加载静态页面)
    - [4. 调用第三方接口](#4-调用第三方接口)
    - [5. 安装Express及简单使用](#5-安装Express及简单使用)
- [8. MongoDB介绍](#8-MongoDB介绍)
    - [1. MongoDB环境配置及安装](#1-MongoDB环境配置及安装)
    - [2. MongoDB基础语法](#2-MongoDB基础语法)
- [9. 基于Node开发商品列表接口](#9-基于Node开发商品列表接口)
    - [1. node启动方式](#1-node启动方式)
    - [2. Express框架开发商品列表接口](#2-Express框架开发商品列表接口)
    - [3. 全局模态框实现](#3-全局模态框实现)
    - [4. 删除购物车的实现](#4-删除购物车的实现)
    - [5. 购物车商品数量的增减更新](#5-购物车商品数量的增减更新)
    - [6. 购物车商品全选和总价计算](#6-购物车商品全选和总价计算)
    - [7. 地址列表渲染实现](#7-地址列表渲染实现)
    - [8. 添加用户支付订单](#8-添加用户支付订单)
- [10. Vuex改造登陆和购物车数量功能](#10-Vuex改造登陆和购物车数量功能)
    - [1. Vuex](#1-Vuex)
    - [2. Vuex语法讲解](#2-Vuex语法讲解)
    - [3. Vuex改造登陆和购物车数量功能中](#3-Vuex改造登陆和购物车数量功能中)
- [11. Vuex改造登陆和购物车数量功能](#11-阿里云服务器数据库搭建-部署)


---


# 2. 前言介绍和环境搭建

## 1. vue和react对比  

不同点：
  1. vue：模板和渲染函数弹性选择；
  2. vue：模板语法和项目创建简单快捷；
  3. vue：更快的渲染速度和更小的体积；
  4. react：更适用于大型应用和更好的可测试性；
  5. react：同时实用Web端和原生App；
  6. react：更大的生态圈和更多的工具；

相同点：
  1. 利用虚拟DOM实现快速渲染；
  2. 轻量级；
  3. 响应式(实时改变)；
  4. 服务端渲染；

- 其中`Angualr`更多的是一套解决方案和一个生态，vue和react使用的是`Virtual Dom`,速度更快。vue不算是一个框架，但结合周边生态构成一个更加灵活的框架。其核心思想是1.数据驱动；2.组件化（抽离公用，模块化）。其中Model和view是双向绑定、没有控制器概念、数据驱动和状态管理，所以称为MV*架构。vue组件：1.全局组件和局部组件；2.父子组件通讯；3.slot插槽。

- 前端路由的优点：体验号，不需要从服务器全部获取，速度快；缺点：不利于SEO，无法缓存（无法让浏览记住浏览位置）

<img src="http://gytblog.oss-cn-shenzhen.aliyuncs.com/blog/vue/1.png" style="width:450px">

## 2. 工程环境配置

1.安装node.js(http://www.runoob.com/nodejs/nodejs-install-setup.html);

2.基于`node.js`,利用淘宝`npm`镜像安装相关依赖;

> npm install -g cnpm --registry=https://registry.npm.taobao.org

3.安装全局vue-cli脚手架,搭建所需的模板框架;

> cnpm install -g vue-cli
> init webpack-simple Test
> cnpm install
> cnpm run dev

---

# 3. 路由基础和路由种类

## 1. 安装路由依赖
> npm install vue-router --save 

## 2. vue-router代码解析

**1.在`index.js`路由配置文件中添加如下代码，包含嵌套路由、动态路由匹配、编程式路由。**

```java 
Vue.use(Router)
//动态路由匹配 goods/:goodsId  params父路由向子路由传参
//嵌套路由匹配 父路由和多个子路由
//编程是路由匹配
//命名路由和命名视图 this.$router.push("/cart") = this.$router.push({path:"/cart"})  this.$router.go(-2)页面跳转
//router-link路由跳转，router-view路由界面渲染
export default new Router({
  routes: [
    {
      path: '/',
      name: 'GoodsList',
      components:{
        default:GoodsList,
        title:Title,
        img:Image,
      } ,
      children: [
        {
          path: 'title',
          name: 'title',//命名路由
          component: Title
        },

        {
          path: 'image',
          name: 'image',
          component: Image
        }

      ]
    },
    {
      path:'/cart/:cartId',//动态路由
      name:'cart',
      component:Cart
    }
  ]
})

```

**2. 父路由`GoodsList.vue`文件中的代码**

```java
<template>
  <div>
    这是商品列表页面
    <span>{{$route.params.goodsId}}</span><br>
    <span>{{$route.params.name}}</span>
    <router-link to="/goods/title">显示商品标题</router-link>
    <router-link to="/goods/image">显示商品图片</router-link>
    <div>
      <router-view></router-view>
    </div>
    <router-link v-bind:to="{name:'cart',params:{cartId:123}}">跳转到购物车页面</router-link><!--命名路由跳转,动态路由传参params-->
    <button @click="jump">跳转页面</button>

  </div>
</template>
<style>

</style>
(script)//方便显示
  export default{
    data(){
      return {
        msg: 'hello vue'
      }
    },
    methods: {
      jump(){
        //this.$router.push({path:'/cart'})
        //this.$router.push('/cart?goodsId=456')//传参到子路由
        //this.$router.go(-2)//页面回退两步
        history.go(-1)//回退效果是一样的
      }
    }

  }

  //路由跳转和路由渲染
</script>

```

---

# 4. Vue-resource/Axios

## 1. 插件安装

> cnpm install vue-resource --save 
> cnpm install axios --save 

**1.vue-resource的请求API是按照REST风格设计的，提供了7种请求API**

<img src="http://gytblog.oss-cn-shenzhen.aliyuncs.com/blog/vue/2.png" style="width:450px">

## 2. Vue-resource插件介绍

**下面代码展示了get请求、post请求、jsonp请求、http请求、interceptors全局拦截器的使用。ajax能做的事情，它照样能做**

```java
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
  <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <script src="node_modules/vue/dist/vue.js"></script>
  <script src="node_modules/vue-resource/dist/vue-resource.js"></script>
</head>
<body>
<div id="app" class="container">
  <h1>vue-resource插件讲解</h1>
  <a href="javascript:" class="btn btn-primary" v-on:click="get">Get请求</a>
  <a href="javascript:" class="btn btn-primary" @click="post">Post请求</a>
  <a href="javascript:" class="btn btn-primary" @click="jsonp">JSONP请求</a>
  <a href="javascript:" class="btn btn-primary" @click="http">http请求</a>
  <div>
    <span>{{msg}}</span>
  </div>
</div>

(script)//方便显示
  new Vue({
    el: "#app",
    data: {
      msg: ''//报文
    },
    mounted: function () {//全局拦截器
      //拦截请求前后
      Vue.http.interceptors.push(
        function (request, next) {
          console.log("request init");
          next(function (response) {
            console.log("response init");
            return response;
          })

        })
    },
    http: {
      root: "http://localhost:63342/ImoocMall/"//全局地址配置
    },

    methods: {
      get: function () {
        this.$http.get("package.json", {//vue 实例和请求json
          params: {
            userId: "101"
          },//URL参数
          headers: {
            token: "abcd",
          }
        }).then(res => {//ES6方法解析  成功回调
          this.msg = res.data;//报文结果

        }, error => {//错误回掉
          this.msg = error;
        });

      },
      post: function () {
        this.$http.post("package.json", {
          userId: "102"
        }, {
          headers: {
            access_token: "abc"
          }
        }).then(function (res) {
          this.msg = res.data//res封装了结构
        });
      },


      jsonp: function () {//跨域请求
        this.$http.jsonp("https://www.imooc.com/course/AjaxCourseMembers?ids=903").then(function (res) {
          this.msg = res.data
        })
      },


      http: function () {
        this.$http({
          url: "package.json",
          params: {
            userId: "103"
          },
          headers: {
            token: "123"
          },
          timout: 5,
          before: function () {
            console.log("before init.")

          }
        }).then(function (res) {
          this.msg = res.data;

        });
      }
    }
  });
</script>

</body>
</html>

```

## 3. Axios插件介绍
**vue2.0之后，就不再对vue-resource更新，推荐使用axios插件，基于Promise的HTTP请求客户端**

```java
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <!-- 最新版本的 Bootstrap 核心 CSS 文件 -->
  <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <script src="../node_modules/axios/dist/axios.js"></script>
  <script src="../node_modules/vue/dist/vue.js"></script>

</head>
<body>
<div id="app" class="container">
  <h1>axios插件讲解</h1>
  <a href="javascript:" class="btn btn-primary" v-on:click="get">Get请求</a>
  <a href="javascript:" class="btn btn-primary" @click="post">Post请求</a>
  <a href="javascript:" class="btn btn-primary" @click="http">http请求</a>
  <div>
    <span>{{msg}}</span>
  </div>
</div>

(script)//方便显示

  //cnpm  install axios --save
  //package.json{dependencies:上线后都要使用的依赖；devdependencies：工程使用以来，上线前解析好}

  new Vue({
    el: "#app",
    data: {
      msg: ''//报文
    },
    mounted: function () {//全局拦截器
      //拦截请求前后
      axios.interceptors.request.use(function (config) {
        console.log("request init.");
        return config;
      })
      axios.interceptors.response.use(function (response) {
        console.log("response init.")
        return response;

      })

    },

    methods: {
      get: function () {
        axios.get("../package.json", {
          params: {
            userId: '999'
          },
          headers: {
            token: 'jack'
          }
        }).then(res => {
          this.msg = res.data;
        }).catch(function (error) {//捕获异常
          console.log("error init." + error)
        });
      },
      post: function () {
        axios.post('../package.json', {
          userId: '888'
        }, {
          headers: {
            token: 'tom'
          }
        }).then(res => {
          this.msg = res.data;
        }).catch(function (error) {
          console.log('error init.' + error);
        })
      },

      http: function () {//配置方式请求
        axios({
          url: "../package.json",
          method: "get",
          data: {
            userId: 'post方式的数据定义'
          },
          params: {
            userId: 'get方式的的数据定义'
          },
          headers: {
            token: "http-test"
          }
        }).then(res => {//es6 箭头函数的作用域与外保持一致
          this.msg = res.data;

        })
      }
    }
  });
</script>

</body>
</html>

```

---

# 5. ES6基础和Promise讲解

## 1. ES6的基础知识变量作用域

```java
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ES6演示</title>
  <style>
    .log {
      background-color: black;
      color: white;
      padding: 10px 20px;
    }
  </style>
</head>
<body>
<h2>ES6演示</h2>
<div id="log" class="log"></div>
(script)//方便显示
  //let和const是块级作用域，var非块级
  //const常量定义无法改变
  //尽量使用let 避免作用域错误
  var str = `
      console.log("a" + a);
      var a = 1;
      console.log("b" + b);
      let b = 2;
      console.log("a" + a);
      var a = 1; //定义提前
      console.log("b" + a);//error
      let a = 1; //函数级，不能提前
      //块级作用域
      {
        let a = 1;
        var b = 2;
      }

      console.log("a:" + a);//error
      console.log("b:" + b);

    function add(flag) {
      if(flag) {
        return "true";
      }else{
        return "error";
      }
    }

    function sum(flag = true) {
      if(flag) {
        return "true";
      }else{
        return "error";
      }
    }
    console.log(sum());
    var arr = [3, 6, 9]
    var newArr = arr.map(function (item) {
        item+=1;
      return item + 2;
    })
    //箭头函数
    var newArr1=arr.map((item)=>item+2)//内部代码一行
    console.log(newArr1)
   `;//模板语言

  printLog(str);
  var [a, b, c]=[3, 5, 7];//数组的解构 分解
  var [x, y, z]="vue";//字符串的分解
  console.log(`x:${x},y:${y},z:${z}`);
  var {m, n} = {m: 10, n: 20};//对象的解构，对key进行拆分
  console.log(`m:${m},n:${n}`);
  function sum([x, y]) {//函数的解构
    return x + y;
  }
  var total = sum([3, 8]);
  console.log(`total:${total}`);

  let userName = "Jack";
  printLog(`I am ${userName}`);

  function printLog(str) {
    document.getElementById("log").innerText = str;
  }
</script>
</body>
</html>

```

## 2. ES6参数、函数、数组

```java
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ES6-1演示</title>
</head>
<body>
<h2>
  ES6-1演示
</h2>
(script)//方便显示
  function sum(x, y, z) {
    let total = 0;
    if (x) total += x;
    if (y) total += y;
    if (z) total += z;
    console.log(`total:${total}`)
  }
  sum(5, "", 9);
  function sum2(...m) {//reset参数，不确定接收的参数个数
    let total = 0;
    for (var i of m) {
      total += i;
    }
    console.log(`total:${total}`)
  }
  sum2(4, 8, 6, 10)

  let sum3 = (...m)=>{//ES6的箭头函数
    let total = 0;
    for (var i of m) {
      total += i;
    }
    console.log(`total:${total}`)
  }
  sum3(4, 8, 6, 10)
  var [x,y] = [4,7]
  console.log(...[4,8]);//reset参数，数组结合，函数的扩展，拆解数组
  let arr1 = [1,2];
  let arr2 = [5,7];
  console.log("concat:"+arr1.concat(arr2));
  console.log([...arr1,...arr2]);
  var [m1,...n1] = [4,5,6,7]//reset将n1动态控制数组个数
  let [A,B,C] = "ES6";//字符串分解
  let xy = [...'ES6'];//将字符串解构成数组

</script>
</body>
</html>

```

## 3. Promise的使用方法

```java
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Promise</title>
</head>
<body>
(script)//方便显示
  let checkLogin = function () {
    return new Promise(function (resolve, reject) {//返回promise .then调用
      //两个参数表示异步操作执行成功和失败的回调函数
      let flag = document.cookie.indexOf("userId") > -1 ? true : false//说明有cookie

      if (flag = true) {//赋真值测试
        resolve({//写入数据
          status: 0,
          result: true
        })
      } else {
        rejet("error");
      }
    })
  };
  let getUserInfo =()=>{//封装用户信息
      return new Promise((resolve,reject)=>{
          let userInfo={
              userId:"101"
          }
          resolve(userInfo);
      })
  }

  //方式1
  checkLogin().then((res)=> {//回调函数
    if (res.status == 0) {
      console.log("login success"+res.result);
      return getUserInfo();//登陆成功返回用户信息
    }
  }).catch((error) => {
    console.log(`error:${error}`)
  }).then((res1)=>{//回调函数 链式调用
      console.log(`userId:${res1.userId}`)
  })

//方式2
  Promise.all([checkLogin(),getUserInfo()]).then(([res1, res2])=>{
      console.log(`result1:${res1.result},result2:${res2.userId}`)
  })
</script>
</body>
</html>

```

---

# 6. 模块组件化和数据加载

## 1. 模块组件化

```java

<template>
  <div><!--copy静态元素的时候，必须要有一个根元素-->
    <!--h5不支持大写，中间大写字母转化成'-'.-->
    <nav-header></nav-header>
    <nav-bread>
      <span slot="bread"></span>
      <!--slot插槽插入信息-->
    </nav-bread>
    <goods></goods>
    <nav-footer></nav-footer>

  </div>
</template>

(script)//方便显示
  //总结：
  //1.静态页面的组件划分
  //2.header footer 面包屑
  //3.组件的导入及书写规范
  import './../assets/css/base.css'
  import './../assets/css/product.css'
  import './../assets/css/login.css'

  import NavHeader from './../components/NavHeader'
  import NavFooter from './../components/NavFooter'
  import NavBread from './../components/NavBread'
  import Goods from './../components/Goods'

  export default{
    data(){
      return {
        msg: 'hello vue'
      }
    },
    components: {
      NavHeader,
      NavFooter,
      NavBread,
      Goods,
    }

  }
</script>

```

## 2. 数据渲染加载

**1.在使用vue开发过程中，难免需要去本地数据地址进行请求，而原版配置在dev-server.js中，新版vue-webpack-template已经删除dev-server.js，改用webpack.dev.conf.js代替，所以 配置本地访问在webpack.dev.conf.js里配置即可。**

```java
 var express = require('express')
 var app = express()

 var router = express.Router();
 var goodsData = require('./../mock/goods.json');

 app.use(router);

 //在devServe下添加
      before(app) {
      app.get('/goods', (req, res) => {
          // 这里是你的json内容
          res.json(goodsData);

      })
    }
 ```
**2.从路由端获取json数据**

```java

import axios from 'axios'

  export default{
    data(){
      return {//返回一个object
        goodsList: []
      }
    },
    components: {
      NavHeader,
      NavFooter,
      NavBread,
    },
    mounted: function () {
      this.getGoodsList();//初始化调用函数
    },
    methods: {
      getGoodsList(){
        axios.get("/goods").then((result) => {//从/goods路由获取json数据
          var res = result.data;
          this.goodsList = res.result;//讲json数据扔给goodList
        })

      }
    }

  }
```

**3.在html标签中遍历json数据**

 > <li v-for="(item,index) in goodsList">

 > v-bind:src=""

 > {{item.productName}}

 ## 3. 实现图片懒加载

 **1.插件安装**
 
 > cnpm install vue-lazyload --save

```java
import VueLazyLoad from 'vue-lazyload'

Vue.use(VueLazyLoad,{
  loading:"./../../static/loading-svg/loading-bars.svg"
});//加载动画

v-bind:src   ===>>>>   v-lazy

```


# 7. NODE相关知识点

## 1. NODE安装配置

<img src="http://gytblog.oss-cn-shenzhen.aliyuncs.com/blog/vue/3.png" style="width:450px">

## 2. NODE基础编程-http

```java
//User.js

//模块暴露方式1
/*module.exports = {
  userName: 'JACK',
  sayHello: function () {
    return 'Hello';
  }
}*/

//模块暴露方式2
exports.userName = "Tom";
exports.sayHello = function () {
  return 'world';
}

//Demo.js

/**
 * Created by Gump on 2017/12/11.
 */
//let user = require('./User');//一个js文件代表一个模块
//nodejs是服务器端，基于chrome V8引擎，不需要编译即可运行
//console.log(`I'm ${user.userName},I say ${user.sayHello()}`);

let http = require('http');//加载http模块,服务端和客户端
//http.server是一个基于事件的HTTP服务器
//http.request是一个HTTP客户端工具,用户向服务器发送数据
let url = require('url');//加载url模块
let util = require('util')//字符串的处理模块

let server = http.createServer((req, res) => {
  res.statusCode = 200;//服务端状态码
  res.setHeader("Content-Type", "text/plain;charset=utf-8");//服务器响应头
  console.log("url:" + req.url);//打印url字符串  url:/
  console.log("parse:"+url.parse(req.url));//打印object对象  parse:[object Object]
  console.log("inspect:"+util.inspect(url.parse(req.url)));//将对象转为字符串，解析url
  res.end(util.inspect(url.parse(req.url)));//响应结束
  //inspect将对象转换成字符串输出 parse将url转为对象
  //node还未完整url解析 Express的original方法可以拿到完整url
});

server.listen(3000, '127.0.0.1', function () {//监听端口，回调函数
  console.log("服务器已相应，请打开浏览器，输入：http://127.0.0.1:3000");
});


```
## 3. NODE搭建服务器加载静态页面

**搭建node服务器，加载静态页面**

```java

/**
 * Created by Gump on 2017/12/11.
 * 加载文件下的静态页面
 */
let http = require('http');//加载http模块,服务端和客户端
let url = require('url');//加载url模块
let util = require('util')//字符串的处理模块
let fs = require('fs')//文件操作模块

let server = http.createServer((req, res) => {
  //res.statusCode = 200;//服务端状态码
  //res.setHeader("Content-Type", "text/plain;charset=utf-8");//服务器响应头
  var pathname = url.parse(req.url).pathname;//提取url对象的pathname
  fs.readFile(pathname.substring(1), function (err, data) {//去掉斜杠
    if (err) {
      res.writeHead(404, {
        'Content-Type': 'text/html'
      })
    } else {
      res.writeHead(200, {
        'Content-Type': 'text/html'
      });
      res.write(data.toString());//文件系统写入数据
    }
    res.end();//响应结束
  });
});


server.listen(3000, '127.0.0.1', function () {//监听端口，回调函数
  console.log("服务器已相应，请打开浏览器，输入：http://127.0.0.1:3000");
});

```

## 4. 调用第三方接口

```java
/**
 * Created by Gump on 2017/12/11.
 */
//客户端：调用第三方接口或其它服务

var http = require('http');
http.get("http://www.imooc.com/u/card", function (res) {//调用接口数据
  let data = '';
  res.on("data", function (chunk) {
    data += chunk;//取数据

  });
  res.on("end", function () {
    let result = JSON.parse(data);//JSON数据
    console.log("result:" + result.msg);
  })
});

```

## 5. 安装Express及简单使用

> cnpm install -g express

> express test

**Express中使用的jade，如果改用html需要配置ejs**

> cnpm install ejs --save

**_入口文件app.js添加下代码_**

> var ejs = require('ejs');

> app.engine('.html',ejs.__express);

> app.set('view engine', 'jade'); 修改为=> app.set('view engine', 'html');

---

# 8. MongoDB介绍

## 1. MongoDB环境配置及安装

**_MongoDB相对Mysql，特点是高扩展性、分布式存储、低成本、结构灵活_**

**_可视化工具MongoVUE和robomongo都不支持MongoDB3.0版本以后的，建议使用studio 3T_**

**windows下安装：1.下载安装包；2.添加db存储和日志存储文件；3.添加服务、配置环境变量、启动Mongo。**

(1) 下载相应版本，配置mongo,新建一个MongoDB文件夹，文件下data、etc、logs，在etc文件新建mongo.conf添加下面内容：

> dbpath=C:\MongoDB\data #数据库路径

> logpath=C:\MongoDB\logs\mongo.log #日志输出文件路径

> logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件

> journal=true #启用日志文件，默认启用

> quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false

> port=27017 #端口号 默认为27017

(2)启动mongo，将`bin`目录添加环境变量中去

> cd C:\Program Files\MongoDB\Server\3.4\bin

> mongod --dbpath c:\MongoDB\data --logpath c:\MongoDB\log\mongo.log --journal

> mongod --config c:\MongoDB\etc\mongo.conf --install --serviceName "MongoDB"

**平时启动，配置了环境变量，可以在任意路径下依次执行下面命令来启动**

> mongod --dbpath c:\MongoDB\data //制定路径启动方式1

> mongo //命令行终端操作数据库

> net start MongoDB  //管理员权限服务启动方式2  采用此方式直接启动数据库

> net stop MongoDB


## 2. MongoDB基础语法

> show dbs

> db.createCollection("user")

> show collections

> db.collectionsName.drop() //删除集合

> db.user.insert({usrId:101,userName:'jack',userAge:28.class:{name:'imooc',num:10,}}) //插入

> db.user.update({userName:'jack'},{$set:{userAge:44}}) //修改

> db.user.update({'userName':'jack'},{$set:{'class.name':'change'}}) //修改子文档

> db.user.find({userName:'jack'}) //查询

> db.user.find({'class.name':'ali'}) //查询子文档

> db.user.find({userAge:{$gt:20}}) //查询年龄大于20   小于$lt、等于$eq、大于等于$gte

> db.user.remove({userId:101}) //删除

> db.dropDatabase() //删除数据库 先use对象数据库

---

# 9. 基于Node开发商品列表接口

## 1. node启动方式

1.直接node命令启动；
2.配置webstorm启动方式；
3.安装pm2插件启动：
**_进程方式运行启动，并有相关信息和日志——**

> pm2 list

> pm2 start www

> pm2 stop www

## 2. Express框架开发商品列表接口

1.安装Mongoose插件，对数据库进行操作；
2.创建model；
3.创建路由；
4.基于mongoose，实现商品列表的查询功能；

**—服务器端口是3000，与数据库关联；前端端口是8080端口，前端访问数据，即要跨域转发内容，`proxyTable`实现跨域功能。—**


**_server目录下的文件代码_**
```java

/**
 * 1.文件目录`\models\goods.js`
 * Created by Gump on 2017/12/21.
 */
var mongoose = require('mongoose')
var Schema = mongoose.Schema;

var productSchema = new Schema({
  "productId": String,
  "productName": String,
  "salePrice": Number,
  "productImage": String,

});
module.exports = mongoose.model('Good', productSchema);



/**
 * 2.文件目录`\views\app.js`
 * 添加以下代码
 */

 var goods  =require('./routes/goods')
 app.use('/goods',goods);



/**
 * 3.文件目录`\routes\goods.js
 * Created by Gump on 2017/12/21.
 */
var express = require('express');
var router = express.Router();
var mongoose = require('mongoose');
var Goods = require('../models/goods');


//连接MongoDB数据库
mongoose.connect('mongodb://127.0.0.1:27017/dumall');

mongoose.connection.on('connected', function () {
  console.log("MongoDB connnected success.");
});
mongoose.connection.on('error', function () {
  console.log("MongoDB connected fail.");
});
mongoose.connection.on('disconnected', function () {

});

router.get("/", function (req, res, next) {
  //res.send('hello,goods list.');
  Goods.find({},function (err,doc) {
    if(err){
      res.json({
        status:'1',
        msg:err.message
      });
    }else {
      res.json({
        status:'0',
        msg:'',
        result:{
          count:doc.length,
          list:doc,

        }
      })
    }
  })
});

module.exports = router; //输出才能加载

```

**_前端显示数据库里面的数据_**

```java
/**
 * 文件目录`\build\webpack.dev.conf.js
 * Created by Gump on 2017/12/21.
 */
    proxyTable: {
      '/goods':{//访问goods，转发代理3000端口(数据库端口地址)，跨域
        target:'http://localhost:3000'
      }
    },

```

## 3. 列表分页和排序

**_页面资源加载插件，滚动加载（滚动条滚到到哪儿加载到哪儿） 用vue-infinite-scroll插件，用npm安装_**

```java
//server文件下的goods.js,连接数据库，获取数据信息，进行操作
//http://localhost:8080/goods?page=1&pageSize=8&sort=1
//google浏览器安装Json-handle插件
//将数据库前八条数据按照升序排列
  let sort = req.param("sort"); //排序方式
  let page = parseInt(req.param("page"));//页数
  let pageSize = parseInt(req.param("pageSize"));//数据条数
  let skip = (page - 1) * pageSize;//将数据按照pageSize的条数来分页
  let params = {};//Goods.find(parms)存储数据库所有数据
  let goodsModel = Goods.find(params).skip(skip).limit(pageSize);//跳过已经查询过的数据
  goodsModel.sort({'salePrice': sort});//讲salePrice按照sort方式进行排序

```

**下拉加载数据插件`vue-infinite-scroll`的添加方式**

```java
\\cnpm安装插件并导入插件
import infiniteScroll from 'vue-infinite-scroll'


\\添加静态资源并添加svg矢量加载图
<div class="view-more-normal" v-infinite-scroll="loadMore" infinite-scroll-disabled="busy" infinite-scroll-distance="30">
  <img src="../assets/loading-spinning-bubbles.svg" v-show="loading" >
</div>

\\事件添加
loadMore(){   // 滚动加载插件方法
  this.busy = true; // 滚动就禁用，防止下一个滚动
  setTimeout(() => {   // 一个滚动完成之后再滚动加载下一个
    this.page++; //数据加载添加
    this.getGoodsList(true);  // 滚动加载是累加数据，并不是只显示一页数据，so需要传参去请求数据的地方判断一下
  }, 500);
}
```

---


# 9. 用户登陆模块实现

## 1. 登陆登出功能实现

**新建用户模型`user.js`**

```java
\\user.js模型

// 对应数据库用户数据在resource文件夹的dumall-users
var mongoose = require('mongoose');
var Schema = mongoose.Schema;

// 定义一个Schema
var userSchema = new Schema({
  'userId':String,   // 或者 'userId':{type:String}
  'userName':String,
  'userPwd':String,
  'orderList':Array,
  'cartList':[           // 购物车列表
    {
      "productId":String,
      "productName":String,
      "salePrice":Number,
      "productImage":String,
      "checked":String,     // 是否选中
      "productNum":String  // 商品数量
    }
  ],
  "addressList":Array
})

// 输出(导出)
module.exports = mongoose.model('user',userSchema); // 定义一个user模型，可以根据这个模型调用其API方法。
// 这个模型定义的是数据库dumall的users集合数据，所以这个model取名user是对应这个集合，连接数据库之后，这个模型会根据名字的复数形式"users"来查找数据集合。
// module.exports = mongoose.model('user',userSchema,'users'); 也可以后面注明链接的是数据库的goods集合

```

**新建路由`user.js`,实现登陆登出**

```java
var express = require('express');
var router = express.Router();

var User = require('./../models/users')

/* GET users listing. */
router.get('/', function (req, res, next) {
  res.send('respond with a resource');
});

router.post("/login", function (req, res, next) {
  var param = {
    userName: req.body.userName,
    userPwd: req.body.userPwd,
  }
  User.findOne(param, function (err, doc) {
    if (err) {
      res.json({
        status: '1',
        msg: "账号密码错误"
      });
      console.log("erro")
    } else {
      if (doc) {
        res.cookie("userId", doc.userId, {//cookies存储用户信息
          path: '/',
          maxAge: 1000 * 60 * 60
        });
        res.cookie("userName", doc.userName, {
          path: '/',
          maxAge: 1000 * 60 * 60
        });
        //req.session.user = doc;
        res.json({
          status: '0',
          msg: '',
          result: {
            userName: doc.userName
          }
        })
      }

    }
  });

})

//登出接口
router.post("/logout",function (req,res,next) {
  res.cookie("userId","",{//登出销毁用户信息
    path:"/",
    maxAge:-1,
  });
  res.cookie("userName","",{
    path:"/",
    maxAge:-1,
  });
  res.json({
    status:0,
    msg:'',
    result:'',
  })

})

module.exports = router;

```

**前端实现代码`NavHeader.vue`**

```java
    methods: {
      login(){
        if (!this.userName || !this.userPwd) {//用户密码为空是报错
          this.errorTip = true;
          return;
        }
        axios.post("/users/login", {//向服务器提交用户信息
          userName: this.userName,
          userPwd: this.userPwd,
        }).then((response) => {

          let res = response.data;
          if (res.status == "0") {
            this.errorTip = false;
            this.loginModalFlag = false;
            this.nickName = res.result.userName;
            //todo
          } else {
            this.errorTip = true;
          }
        })

      },
      loginOut(){
          axios.post("/users/logout").then((response)=>{
              let res =response.data;
              if(res.status=="0"){
                  this.nickName='';
              }
          })
      }
    }
```


## 2. 全局登陆拦截

**全局拦截作用是在未登录的情况下，禁掉某些页面功能，`app.js`中添加代码，登陆登出对`cookie`进行操作**

```java
app.use(function (req,res,next) {
  if(req.cookies.userId){\\在cookie中检查到用户信息,那么畅通无阻
    next();
  }else{
    console.log("url:"+req.originalUrl);
    if(req.originalUrl=='/users/login' || req.originalUrl=='/users/logout' || req.path=='/goods/list'){\\将某些功能设置为白名单
      next();
    }else{
      res.json({
        status:'10001',
        msg:'当前未登录',
        result:''
      });
    }
  }
});

```

**登陆校验，从`cookies`获取用户信息来判断是否登陆状态，以上登陆和登出操作会将cookies的用户信心增加和删除，那么通过cookies来得知是否登陆，效果是登陆了，刷新页面依然保持登陆状态。判断cookies中是否有登陆信息，如果有则传递到前端进行显示。**

```java
//登陆检查
router.get("/checkLogin", function (req, res, next) {
  if (req.cookies.userId) {
    res.json({
      status: '0',
      msg: '',
      result: req.cookies.userName
    })
  } else {
    res.json({
      status: '1',
      msg: '未登录',
      result: ''
    })
  }
})
```

**前端添加`methods`方法，在`mounted`数据渲染加载调用钩子下调用方法**

```java
      checkLogin(){
        axios.get("/users/checkLogin").then((response) => {
          var res = response.data;

          if (res.status == "0") {
            this.nickName = res.result;
            console.log("check")

          }
        });
      },
```


## 3. 全局模态框实现

**主要涉及到插槽`slot`和父子组件之间的通信**

```java
<template>
  <div>

    <div class="  md-modal modal-msg md-modal-transition" v-bind:class="{'md-show':mdShow}">
      <div class="md-modal-inner">
        <div class="md-top">

          <button class="md-close" @click="closeModal">Close</button>
        </div>
        <div class="md-content">
          <div class="confirm-tips">
            <slot name="message"></slot>
          </div>
          <div class="btn-wrap">
            <slot name="btnGroup"></slot>
          </div>
        </div>
      </div>
    </div>
    <div class="md-overlay" v-if="mdShow" @click="closeModal" ></div>

  </div>
</template>

(script)
  export default{
    props: ["mdShow"],//向子组件传递参数
    data(){
      return {
        msg: 'hello vue'
      }
    },
    methods:{
      closeModal(){
          this.$emit("close");//触发父组件的close事件
      }
    }

  }
(/script)

//view的两个模态框，也是模态框的子组件

    <modal v-bind:mdShow="mdShow" v-on:close="closeModal">
      <p slot="message">请登陆</p>
      <div slot="btnGroup"><a class="btn btn--m" href="javascript:;" @click="mdShow=false">关闭</a></div>
    </modal>

    <modal v-bind:mdShow="mdShowCart" v-on:close="closeModal">
      <p slot="message">
        <svg class="icon-status-ok">
          <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-status-ok"></use>
        </svg>
        <span>加入购物车成!</span>
      </p>
      <div slot="btnGroup">
        <a class="btn btn--m" href="javascript:;" @click="mdShowCart = false">继续购物</a>
        <router-link class="btn btn--m btn--red" href="javascript:;" to="/cart">查看购物车</router-link>
      </div>
    </modal>


    //子组件的closeModal时间，emit触发的此事件
    closeModal(){
        this.mdShow = false;

      }


```


## 4.删除购物车的实现

**服务器端，定义`cartDel`路由，获取用户cookies中的ID，同时获得前端商品ID，然后进行删除，`pull`删除数据，`push`新增数据。

```java
//购物车删除
router.post("/cartDel", function (req, res, next) {
  var userId = req.cookies.userId;
  var productId = req.body.productId;//获取前端的商品ID
  User.update({
    userId: userId//条件
  }, {
    $pull: {//更新购物车列表
      'cartList': {'productId': productId}
    }
  }, function (err, doc) {
    if (err) {
      res.json({
        status: '1',
        mes: err.message,
        result: ''
      })
    } else {
      res.json({
        status: '0',
        mes: '',
        result: 'suc'
      })
    }
  })
})
```
**前端，发送商品ID，更新数据，更新模态框状态**

```java
delCart(){
      axios.post("/users/cartDel", {
        productId: this.productId//点击的商品ID
      }).then((response) => {
        let res = response.data;//向后端发送数据
        if (res.status == '0') {
          this.modalConfirm = false;//关闭模态框
          this.init();//刷新页面数据
        }
      });
    },
    closeModal(){
      this.modalConfirm = false;
    }
```
## 5. 购物车商品数量的增减更新


**前端显示的逻辑，增减显示，价格计算显示，向后台传递商品数量**

```java
  editCart(flag, item){
    if (flag == "add") {
      item.productNum++;//增加商品数量
    } else if (flag == "minu") {
      if (item.productNum <= 1) {
        return;
      }
      item.productNum--;//减少商品数量
    } else {
      item.checked = item.checked == "1" ? '0' : '1';
    }
    axios.post("/users/cartEdit", {
      productId: item.productId,//获取并发送前端商品ID
      productNum: item.productNum,//获取并发送前端商品数量
      checked: item.checked,
    }).then((response) => {
      let res = response.data;
    })
  }
```

**后台接受更新的商品数量，更新数据库**

```java

//更新商品数量
router.post("/cartEdit",function (req,res,next) {
  var userId =req.cookies.userId;//获取cookies中的用户ID
  var productId =req.body.productId;//获取前端的商品ID
  var productNum =req.body.productNum;//获取前端的商品数量
  User.update({"userId":userId,"cartList.productId":productId},{//更新子文档条件
    "cartList.$.productNum":productNum,//更新商品数量
  },function (err,doc) {//回调函数
    if (err) {
      res.json({
        status: '1',
        mes: err.message,
        result: ''
      })
    } else {
      res.json({
        status: '0',
        mes: '',
        result: 'suc'
      })
    }
  })
})
```
## 6. 购物车商品全选和总价计算

**定义前端全选按钮事件**
```java
 toggleCheckAll(){
  var flag = !this.checkAllFlag;
  //this.checkAllFlag = !this.checkAllFlag; computed实时计算，赋不了值
  this.cartList.forEach((item) => {
    item.checked = flag ? '1' : '0';
  });
  axios.post("/users/editCheckAll", {
    checkAll: flag
  }).then((response) => {
    let res = response.data;
    if (res.status == '0') {
      console.log("update suc");
    }
  })

}
```
**服务端路由，数据库处理**

```java
router.post("/editCheckAll", function (req, res, next) {
  var userId = req.cookies.userId;//获取cookies中的用户ID
  var checkAll = req.body.checkAll?'1':'0';//全选标志位定义
  User.findOne({userId: userId}, function (err, user) {//user用户查询
    if (err) {
      res.json({
        status: '1',
        mes: err.message,
        result: ''
      })
    } else {
      if (user) {//数据库存在此用户
        user.cartList.forEach((item) => {//遍历数据库购物车商品
          item.checked = checkAll;//是否选中状态赋值
        })
        user.save(function (err1, doc) {//存入数据库
          if (err1) {
            res.json({
              status: '1',
              mes: err1.message,
              result: ''
            })
          } else {
            res.json({
              status: '0',
              mes: '',
              result: 'suc'
            })
          }
        })
      }

    }
  })

})

```
## 7. 地址列表渲染实现

**结账按钮实现，为勾选商品，则禁用按钮，添加禁用`class`，同时添加路由逻辑，防止去掉class后，点击跳转**

```java

//html 代码

<a class="btn btn--red" v-bind:class="{'btn--dis':checkedCount==0}" @click="checkOut">Checkout</a>

//js点击事件
checkOut(){
  if (this.checkedCount > 0) {
    this.$router.push({
      path: "/address" //代码路由配置
    });
  }
}


```
**`router-link`点击路由跳转，并带参跳转**

```java
<router-link class="btn btn--m btn--red" v-bind:to="{path:'orderConfirm',query:{'addressId':selectedAddrId}}">下一步</router-link>
```

## 8. 添加用户支付订单

```java

//订单路由服务
router.post("/payMent", function (req,res,next) {
  var userId = req.cookies.userId,
    addressId = req.body.addressId,
    orderTotal = req.body.orderTotal;
  User.findOne({userId:userId}, function (err,doc) {
    if(err){
      res.json({
        status:"1",
        msg:err.message,
        result:''
      });
    }else{
      var address = '',goodsList = [];
      //获取当前用户的地址信息
      doc.addressList.forEach((item)=>{
        if(addressId==item.addressId){
          address = item;
        }
      })
      //获取用户购物车的购买商品
      doc.cartList.filter((item)=>{
        if(item.checked=='1'){
          goodsList.push(item);
        }
      });

      var platform = '622';
      var r1 = Math.floor(Math.random()*10);
      var r2 = Math.floor(Math.random()*10);

      var sysDate = new Date().Format('yyyyMMddhhmmss');
      var createDate = new Date().Format('yyyy-MM-dd hh:mm:ss');
      var orderId = platform+r1+sysDate+r2;//构成orderID
      var order = {
        //添加数据库的字段
        orderId:orderId,
        orderTotal:orderTotal,
        addressInfo:address,
        goodsList:goodsList,
        orderStatus:'1',
        createDate:createDate
      };

      doc.orderList.push(order);

      doc.save(function (err1,doc1) {
        if(err1){
          res.json({
            status:"1",
            msg:err.message,
            result:''
          });
        }else{
          res.json({
            status:"0",
            msg:'',
            result:{
              //显示orderId和总金额
              orderId:order.orderId,
              orderTotal:order.orderTotal
            }
          });
        }
      });
    }
  })


//前端点击事件逻辑
payMent(){
  var addressId = this.$route.query.addressId;
  axios.post("/users/payMent", {
    //传递ID和金额
    addressId: addressId,
    orderTotal: this.orderTotal,
  }).then((response) => {
    let res = response.data;
    if (res.status == "0") {
      this.$router.push({
          path:'/orderSuccess?orderId'+res.result.orderId
      })
    }
  })
}
``` 
----

# 10. Vuex改造登陆和购物车数量功能

## 1. Vuex

- Vuex是一个专为Vue.js应用程序开发的状态管理模式。
- Vuex可以更好的帮助组件外部同意管理状态。
- 核心概念：state、mutations、getters、modules、actions。

**1.state是唯一的数据源和单一的状态树**
```java
const Counter = {
  template:`<div>{{count}}</div>`,
  computed:{
    count(){
      return this.$store.state.count
    }
  }
}

```

**2.通过getters可以派生出一些新的状态**

```java
const sotre = new Vuex.Store({
  state:{
    todos:[
      {id:1,text:'...',done:true},
      {id:2,text:'...',done:false}
    ]
  },
  getters:{
    doneTodos:state=>{
      return state.todos.fileter(todo=>todo.done)
    }
  }
})
```
**3.mutations更改Vuex的store钟的状态的唯一方法是提交mutation**

```java

const store= new Vuex.Store({
  state:{
    count:1
  }
},
mutations:{
  increment(state){
    state.count++
  }
})

//调用函数
store.commit('increment')

```
**4.actions提交的是mutation,而不是直接改变状态。可以包含任意异步操作**

```java
const store = new Vuex.Store({
  state:{
    count:0
  },
  mutations:{
    increment(state){
      state.count++
    }
  },
  actions:{
    increment(context){
      //提交mutation，调用increment方法
      context.commit('increment')
    }
  }
})
```

**5.modules将复杂的状态管理，讲vuex的store对象分割成模块**

```java
const moduleA={
  state:{...}
  mutations:{...}
  actions:{...}
  getters:{...}
}
const moduleB={
  state:{...}
  mutations:{...}
  actions:{...}
  getters:{...}
}
const store  = new Vuex.Store({
  modules:{
    a:moduleA,
    b:moduleB
  }
})
```

## 2. Vuex语法讲解

```java
//导入vuex.min.js
//mutations和actions的使用
(script)
const counter ={
  template:`<div>{{count}}</div>`,
  //实时计算
  computed:{
    count(){
      return this.$store.state.count;
    },
    name(){
      return this.$store.state.name;
    },
    userName(){
      return this.$store.getters.userName;
    }
  }
};
//状态管理
const store = new Vuex.Store({
  state:{
    count:10,
    name:"jack"
  },
  getters:{
    //扩展功能
    userName(state){
      return state.name+",Hello";
    }
  },
  //状态改变
  mutations:{
    increment(state,num){
      state.count = num;
    },
    updateName(state, userName){
      state.name = userName;
    }
  }，
  actions:{
    incrementAction(context,num){
      //用actions提交mutations
      context.commit("increment",num);
    }
  }
});
new Vue({
  el:"#app",
  store,
  date:{
    msg:"Vuex的使用"
  },
  //组件化
  components:{
    counter
  }，
  methods：{
    add(){
      //提交mutations，调用方法
      //方法一：用actions提交，dispatch触发
      this.$store.dispatch("incrementAction",5)

      //方法二：用commit提交
      //this.$store.commit("increment", 100);
      this.$store.commit("updateName", 'Tom')
    }
  }
})
(/script)
```
## 3. Vuex改造登陆和购物车数量功能中

**在`main.js`中声明和注册Vuex及方法**

```java
//导入vuex
import Vuex from 'vuex'
Vue.use(Vuex);
const store = new Vuex.Store({
  state: {
    nickName: '',
    cartCount: 0
  },
  //方法声明
  mutations: {
    //vuex的使用
    //更新用户信息
    updateUserInfo(state, nickName) {
      state.nickName = nickName;
    },
    updateCartCount(state,cartCount){
      state.cartCount += cartCount;
    },
    initCartCount(state,cartCount){
      state.cartCount = cartCount;
    }
  }
});
//注册store
new vue({
  store,
})
```
**在前端组件中`NavHeader.vue`中使用vuex，使用全局数据,实现购物车图标上的数量显示**
```java
    computed: {
      //封装下面方法
      //三个点对数组的解构
      ...mapState(['nickName', 'cartCount'])
//      nickName(){
//        return this.$store.state.nickName;
//      },
//      cartCount(){
//        return this.$store.state.cartCount;
//      }
    },

    //使用此方式提交数据
    this.$store.commit("updateUserInfo", 传参入口);
    //使用此方法想服务器获取商品数据
    getCartCount(){
      axios.get("/users/getCartCount").then((response) => {
        let res = response.data;
        this.$store.commit("initCartCount", res.result);
      })
    }

    //服务端user.js的getCartCount路由
    router.get("/getCartCount",function (req,res,next) {
    if(req.cookies && req.cookies.userId){
      var userId = req.cookies.userId;
      User.findOne({userId:userId},function (err,doc) {
        if (err) {
          res.json({
            status: '1',
            msg: err.message,
            result: ''
          });
        } else {
          var cartList = doc.cartList;
          let cartCount = 0;
          cartList.map(function (item) {
            //获取购物车的全部数量
            cartCount += parseInt(item.productNum);
          });
          res.json({
            status:'0',
            msg:'',
            result:cartCount
          })
        }
      })
    }
  })
```

---


# 11. 阿里云服务器数据库搭建-部署

**1.FileZilla或WinSCP连接服务器，windows安装客户端，服务器安装vsftpd，关掉防火墙，新建用户和密码，本地登陆用户**

**2.上传`mongodb-linux-x86_64-3.6.2.tgz`数据库安装包**

1. 解压压缩包`tar zxvf mongodb-linux-x86_64-3.6.2.tgz`。

2. 更目录建mogodb文件，文件下包含data、etc/mongo.conf、logs/mongo.log。

3. mongo.conf中如下：

> dppath=/mongodb/data
> logpath=/mongodb/logs/mongo.log
> logappend=true
> journal=true
> quiet=true
> port=27017
> bind_ip=0.0.0.0

4. 阿里云服务器设置`27017`端口安全组，新建入口规则。

5. 用本地的studio 3T即可访问服务器数据口，通过ip和端口。

6. 用ssh命令终端远程连接服务器，开启数据库，我用的是现成的`git bash`。

7. 前端用build进行编译，生成`dist`文件，上传到服务器，配置nginx。

8. 配置mongodb和server的开机自启动脚本。

9. mongoDB在进程中运行，配置`fork=true`

**3.在部署遇到了一些坑：1）服务器端口修改；2）nginx跨域配置；3）mongodb和mongoose插件的版本支持**

---


**课程完结，功能添加待续....**