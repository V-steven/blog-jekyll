---
layout: post
title: 前端面试问题及详解
tags: [前端后台]
---

# 一 JavaScript
 
## 1.谈谈闭包

**使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。**

**三特性**
- 1.函数内嵌套函数；
- 2.函数内部可以引用外部的参数和变量；
- 3.参数和变量不会被垃圾回收机制回收；

## 2.谈谈cookie

**2.1 cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。**
- 1.特定域名下IE6只能生成20个cookie；
- 2.每个cookie大小限制在`4K`

**2.2 使用cookie方法**

- 1.控制`cookie`和`session`对象的大小；
- 2.加密技术，减少`cookie`被破解的可能性；
- 3.不在cookie中存放私密信息；
- 4.控制cookie的声明周期，让有有效时间；
- 5.为了防止重复提交表单，在服务器上有计数器；

## 3.谈谈浏览器本地存储

**3.1 js提供了`sessionStorage`和`globalStorage`。在HTML5中的web storage提供了`localStorage`来取代`globalStorage`**

- 1.`sessionStorage`用于本地存储数据,同一个页面中才能访问随之销毁。因此不是一种持久化的本地存储，仅仅是会话级别的存储。
- 2.`localStorage`用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。

**3.2 web storage和cookie的区别**

- 1.`cookie`大小受限，`web storage`更大容量存储；
- 2.每当请求一个新页面，`cookie`都会发送过去，浪费了带宽；
- 3.`cookie`不可跨域调用；
- 4.`cookie`的作用是与服务器交互，作为`HTTP`一部分，而`web storage`为本地存储而生；

**3.3 session和cookie的区别**

- 1.`cookie`放在客户端浏览器，`session`放在服务器上；
- 2.`cookie`安全性没有`session`高；
- 3.`session`会保留在服务器一段时间，访问增多，占用服务器性能，则合理使用`cookie`；
- 4.登陆重信息放在`session`,其它信息可放在`cookie`;

## 数据类型

**逻辑对象无初始值或者其值为 0、-0、null、""、false、undefined 或者 NaN，其对象的值为 false**
**其他1：regExp正则，test()查找字符串，exec()返回字符串，compile()改变regExp中的匹配参数。**
**其他2：window表示浏览器窗口，screen表示屏幕。**
**其他3：警告alert();确认框confirm();提示框prompt()**

---

# 二 CSS部分

## 1.display和visibility区别

- 1.`display:none` 隐藏元素，布局不分配空间；
- 2.`visibility:hidden` 隐藏元素，布局保留空间；

## 2.link和@import区别

- 1.`link`是HTML标签，`@import`是css提供；
- 2.`link`会和页面同时加载，`@import`等页面加载完后加载；
- 3.`@import`在IE5以上兼容，`link`无兼容问题；
- 4.`link`权重高于`@import`；

## 3.position:absolute和float区别

- 1.**共同点**：对内联元素设置`float`和`float`，可以让元素脱离文档流，并可以设置宽高；
- 2.**不同点**：`float`会占据位置，`position`会覆盖文档流中的其它元素；

## 4.介绍box-sizing属性

**`box-sizing`用来控制元素的盒模型的解析模式,默认值是content-box。**

- 1.**content-box**:`W3C`标准盒模型，元素宽高由border、padding、content来确定，width/height属性确定content的宽高；
- 2.**border-box**：`IE`传统盒模型，width/height属性确定border、padding、content的宽高；

## 5.css选择符有哪些

**优先级**：!important > 内联 > id > class > 标签

> * 1.id选择器（ # myid）
> * 2.类选择器（.myclassname）
> * 3.标签选择器（div, h1, p）
> * 4.相邻选择器（h1 + p）
> * 5.子选择器（ul > li）
> * 6.后代选择器（li a）
> * 7.通配符选择器（ * ）
> * 8.属性选择器（a[rel = "external"]）
> * 9.伪类选择器（a: hover, li:nth-child）

## 6.position的使用

- 1.**`absolute`**:绝对定位，相对最近一级不是`static`父元素定位；
- 2.**`fixed`**:绝对定位，相对于浏览器定位；
- 3.**`relative`**:相对定位，相对于普通流中定位；
- 4.**`static`**:没有定位，出现正常流中；

## 7.css3新特性

- 1.实现圆角(border-radius),阴影(box-shadow)；
- 2.文字特效(text-shadow),线性渐变(gradient),旋转(transform);
- 3.更多的css选择器，多背景`rgba`；
- 4.唯一引入的伪元素`::selection`;
- 5.包围边框`border-image`;

## 8. XML和JSON区别

- 1.JSON相对XML数据体积小，传输速度快；
- 2.JSON与JS交互更加方便，更容易解析；
- 3.JSON描述性更差；

----

# 三 HTML部分

## 1.语义化理解

- 1.清晰的页面结构。去掉或样式丢失的时候,也能让页面呈现清晰的结构，增强页面的可读性。
- 2.支持更多的设备。屏幕阅读器会完全根据你的标记来“读”你的网页。更好的支持浏览器的阅读模式等。
- 3.有利于SEO。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。
- 4.便于团队开发和维护。在团队中大家都遵循同一个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。

## 2.Doctype

- 1.`Doctype`不存在，则文档以混杂模式运行；
- 2.**严格模式**：又称标准模式，是指浏览器按照 W3C 标准解析代码;
- 3.**混杂模式**：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码；

## 3.XHTML 与 HTML 之间的差异

- 1.所有的标记都必须要有一个相应的结束标记
- 2.所有标签的元素和属性的名字都必须使用小写
- 3.所有的XML标记都必须合理嵌套
- 4.所有的属性必须用引号""括起来
- 5.把所有<和&特殊符号用编码表示
- 6.给所有属性赋一个值
- 7.不要在注释内容中使“--”
- 8.图片必须有说明文字

## 4.兼容性问题

- 1.png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理；
- 2.浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一；
- 3.IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大；
- 4.浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）；
- 5.这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)；
- 6.渐进识别的方式，从总体中逐渐排除局部；
- 7.同意使用getAttribute()获取自定义属性；
- 8.声明解析模块式`<Doctype html>`;
- 9.超链接访问模式，css排列顺序：a:link {} a:visited {} a:hover {} a:active {}；

## 5.解释浮动原理

**5.1浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。**

- 1.使用空标签清除浮动，添加空标签`clear:both`;
- 2.给浮动元素父标签添加属性`overflow:auto; zoom:1`;
- 3.使用`after`伪对象清除浮动(适用于IE,并设置height:0);

```java
<div style = "clear: both;"> </ div>

#parent:after{
    content:".";
    height:0;
    visibility:hidden;
    display:block;
    clear:both;
    }
```

**5.2浮动元素引起的问题**

- 1.父元素的高度无法被撑开，影响与父元素同级的元素；
- 2.与浮动元素同级非浮动元素会跟随其后；
- 3.若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。

**5.3 IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框**

## 6.添加、移除、移动、复制、创建和查找新节点。

**1.创建新节点**
- 1.createDocumentFragment()    //创建一个DOM片段
- 2.createElement() //创建一个具体的元素
- 3.createTextNode()   //创建一个文本节点

**2.添加、移除、替换、插入**
- 1.appendChild()
- 2.removeChild()
- 3.replaceChild()
- 4.insertBefore() //在已有的子节点前插入一个新的子节点

**3.查找**
- 1.getElementsByTagName()    //通过标签名称
- 2.getElementsByName()    //通过元素的Name属性的值
- 3.getElementById()    //通过元素Id，唯一性

## 6.关于iframe

**缺点**
- 1.解决加载缓慢的第三方内容如广告图片；
- 2.并行加载脚本；

**优点**
- 1.iframe阻塞主页面的`Onload`时间；
- 2.即使内容为空，加载也需要时间；
- 3.没有语意；

---

# 四 其它问题

## 1.如何多个页面之间通信

**调用localstorage、cookies等本地存储**

## 2.线程和进程

- 1.一个程序至少有一个进程,一个进程至少有一个线程；
- 2.进程之间不能共享内存，线程可以；
- 3.线程的划分尺度小于进程，使得多线程程序的并发性高；
- 4.多线程的意义在于一个应用程序找那个，多个执行部分同时执行；

## 3.网站文件和资源优化

- 1.文件合并；
- 2.文件最小化和压缩；
- 3.使用CDN托管；
- 4.缓存的使用（多个域名提供缓存）；

## 4.浏览器访问优化

- 1.减少`HTTP`请求，合理设置`HTTP`缓存（合并CSS、JS、图片）；
- 2.使用浏览器缓存；
- 3.启用压缩，服务器端进行压缩，浏览器端解压缩；
- 4.图片懒加载；
- 5.`CSS`页面顶部，`JS`页面底部；
- 6.异步请求`callback`；
- 7.减少`cookie`传输；

## 5.null和undefined区别

**未初始化变量值为undefined，null表示不存在的对象**

- 1.**`null`**是一个表示"无"的对象，转为数值时为0；
- 2.**`undefined`**表示"无"的原始值，转为数值时为NaN；

## 6.new操作符

- 1.创建一个空对象，并且`this`变量引用该对象，同时还继承了该函数的原型。
- 2.属性和方法被加入到`this`引用的对象中。
- 3.新创建的对象由`this`所引用，并且最后隐式的返回`this`。

## 7.延迟加载


**`懒加载`：defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js**

## 8.跨域问题

** jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面**
    
- jsonp的原理是动态插入script标签



## 9. documen.write和 innerHTML的区别

- 1.document.write重绘整个页面;
- 2.innerHTML可以重绘页面的一部分;

## 10.性能优化方法

- （1）减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。
- （2）前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数
- （3）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
- （4）当需要设置的样式很多时设置className而不是直接操作style。
- （5）少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。
- （6）避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。
- （7）图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

## 11.输入URL到页面加载完成过程

- **步骤1**：发送URL请求，浏览器开启线程处理请求，在远程DNS服务器上开启DNS查询，请求对应的IP;
- **步骤2**：浏览器与远程WEB服务器通过TCP三次握手建立TCP/IP连接，三个报文（同步报文、同步应答报文、应答报文）传递，客户端->服务器->客户端；
- **步骤3**：TCP/IP建立连接后，浏览器向服务器发送HTTP的GET请求，服务器响应返回资源，200为正确响应；
- **步骤4**：web服务器提供资源服务，客户端开始下载资源；

